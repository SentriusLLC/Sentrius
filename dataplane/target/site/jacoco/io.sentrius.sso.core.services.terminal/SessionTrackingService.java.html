<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SessionTrackingService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sentrius-dataplane</a> &gt; <a href="index.source.html" class="el_package">io.sentrius.sso.core.services.terminal</a> &gt; <span class="el_source">SessionTrackingService.java</span></div><h1>SessionTrackingService.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2013 Loophole, LLC
 *
 * &lt;p&gt;Licensed under The Prosperity Public License 3.0.0
 */
package io.sentrius.sso.core.services.terminal;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;

import com.jcraft.jsch.ChannelShell;
import io.sentrius.sso.automation.auditing.PersistentMessage;
import io.sentrius.sso.automation.auditing.Trigger;
import io.sentrius.sso.core.config.SystemOptions;
import io.sentrius.sso.core.services.PluggableServices;
import io.sentrius.sso.core.services.security.CryptoService;
import io.sentrius.sso.protobuf.Session;
import io.sentrius.sso.core.model.ConnectedSystem;
import io.sentrius.sso.core.model.sessions.SessionOutput;
import io.sentrius.sso.core.model.users.User;
import io.sentrius.sso.core.services.auditing.AuditService;
import io.sentrius.sso.core.utils.terminal.UserSessionsOutput;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * Utility to is used to store the output for a session until the ajax call that brings it to the
 * screen
 */
<span class="nc" id="L38">@Slf4j</span>
@Service
<span class="nc" id="L40">@RequiredArgsConstructor</span>
public class SessionTrackingService implements PluggableServices {

  private final SystemOptions systemOptions;
  private final AuditService sessionAuditService;
<span class="nc" id="L45">  private final Map&lt;Long, UserSessionsOutput&gt; userSessionsOutputMap =</span>

      new ConcurrentHashMap&lt;&gt;();

<span class="nc" id="L49">  private final Map&lt;Long, ConnectedSystem&gt; userConnectionMap =</span>
      new ConcurrentHashMap&lt;&gt;();
<span class="nc" id="L51">  private final Map&lt;String, ConnectedSystem&gt; userConnectionMapEncrypted =</span>
      new ConcurrentHashMap&lt;&gt;();

<span class="nc" id="L54">  private static final ExecutorService executor = Executors.newCachedThreadPool();</span>

  private final CryptoService cryptoService;


  public List&lt;ConnectedSystem&gt; getConnectedSession() {
<span class="nc" id="L60">    return new ArrayList&lt;&gt;(userConnectionMap.values());</span>
  }
  /**
   * removes session for user session
   *
   */
  public void removeUserSession(ConnectedSystem connectedSystem) {
<span class="nc" id="L67">    userConnectionMap.remove(connectedSystem.getSession().getId());</span>
<span class="nc" id="L68">      userConnectionMapEncrypted.remove(</span>
<span class="nc" id="L69">          connectedSystem.getSession().getId().toString());</span>
<span class="nc" id="L70">      UserSessionsOutput userSessionsOutput = userSessionsOutputMap.get(connectedSystem.getSession().getId());</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">    if (userSessionsOutput != null) {</span>
<span class="nc" id="L72">      userSessionsOutput.getSessionOutputMap().clear();</span>
    }
<span class="nc" id="L74">    userSessionsOutputMap.remove(connectedSystem.getSession().getId());</span>
<span class="nc" id="L75">  }</span>

  /**
   * removes session output for host system
   *

   */
  public void removeOutput(ConnectedSystem connectedSystem) {

<span class="nc" id="L84">    UserSessionsOutput userSessionsOutput = userSessionsOutputMap.get(connectedSystem.getSession().getId());</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">    if (userSessionsOutput != null) {</span>
<span class="nc" id="L86">      userSessionsOutput.getSessionOutputMap().remove(connectedSystem.getSession().getId());</span>
    }
<span class="nc" id="L88">  }</span>

  /**
   * adds a new output
   *
   * @param sessionOutput session output object
   */
  public void addOutput(SessionOutput sessionOutput) {

<span class="nc" id="L97">    UserSessionsOutput userSessionsOutput = userSessionsOutputMap.get(sessionOutput.getSessionId());</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">    if (userSessionsOutput == null) {</span>
<span class="nc" id="L99">      log.info(&quot;Creating new session output for &quot; + sessionOutput.getSessionId());</span>
<span class="nc" id="L100">      userSessionsOutputMap.put(sessionOutput.getSessionId(), new UserSessionsOutput());</span>
<span class="nc" id="L101">      userSessionsOutput = userSessionsOutputMap.get(sessionOutput.getSessionId());</span>
<span class="nc" id="L102">      userConnectionMap.put(sessionOutput.getSessionId(), sessionOutput.getConnectedSystem());</span>
<span class="nc" id="L103">        userConnectionMapEncrypted.put(sessionOutput.getSessionId().toString().trim(),</span>
<span class="nc" id="L104">            sessionOutput.getConnectedSystem());</span>
    }
    else {
<span class="nc bnc" id="L107" title="All 2 branches missed.">      if (userSessionsOutput.getSessionOutputMap().containsKey(sessionOutput.getSessionId())) {</span>
<span class="nc" id="L108">        log.info(&quot;*not new session output for &quot; + sessionOutput.getSessionId());</span>
<span class="nc" id="L109">        userSessionsOutput.getSessionOutputMap().get(sessionOutput.getSessionId()).append(sessionOutput.getOutput());</span>
<span class="nc" id="L110">        return;</span>
      }
    }
<span class="nc" id="L113">    userSessionsOutput.getSessionOutputMap().put(sessionOutput.getSessionId(), sessionOutput);</span>
<span class="nc" id="L114">  }</span>

  /**
   * adds a new output
   *
   *
   * @param value Array that is the source of characters
   * @param offset The initial offset
   * @param count The length
   */
  public void addToOutput(ConnectedSystem connectedSystem, char[] value, int offset, int count) {
<span class="nc" id="L125">    ConnectedSystem schSession = userConnectionMap.get(connectedSystem.getSession().getId());</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">      if (null != schSession) {</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (schSession.getTerminalAuditor().shouldReceiveFromServer()</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">            || systemOptions.enableInternalAudit) {</span>
<span class="nc" id="L129">          log.trace(&quot;terminal auditor should receive from server&quot;);</span>
<span class="nc" id="L130">          var serverResponse = new String(value, offset, count);</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">          if (schSession.getTerminalAuditor().shouldReceiveFromServer()) {</span>
<span class="nc" id="L132">            log.trace(&quot;Received from server: &quot; + serverResponse);</span>
<span class="nc" id="L133">            schSession.getTerminalAuditor().receiveFromServer(serverResponse.trim());</span>
          }
<span class="nc bnc" id="L135" title="All 2 branches missed.">          if (systemOptions.enableInternalAudit) {</span>
<span class="nc" id="L136">            sessionAuditService.audit(connectedSystem, serverResponse);</span>
          }
<span class="nc" id="L138">        }</span>
        else {
<span class="nc" id="L140">            log.trace(&quot;terminal auditor should not receive from server&quot;);</span>
        }
      }
<span class="nc" id="L143">    UserSessionsOutput userSessionsOutput = userSessionsOutputMap.get(connectedSystem.getSession().getId());</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">    if (userSessionsOutput != null) {</span>
<span class="nc" id="L145">      userSessionsOutput.getSessionOutputMap().get(connectedSystem.getSession().getId()).append(value, offset, count);</span>
    }
<span class="nc" id="L147">  }</span>

  /**
   * returns list of output lines
   *
  * @return session output list

  public List&lt;SessionOutput&gt; getOutput(ConnectedSystem connectedSystem)
      throws SQLException {
    List&lt;SessionOutput&gt; outputList = new ArrayList&lt;&gt;();

    UserSessionsOutput userSessionsOutput = userSessionsOutputMap.get(connectedSystem.getSession().getId());
    if (userSessionsOutput != null) {

      for (Long key : userSessionsOutput.getSessionOutputMap().keySet()) {

        // get output chars and set to output
        SessionOutput sessionOutput = userSessionsOutput.getSessionOutputMap().get(key);

        if (sessionOutput != null
            &amp;&amp; sessionOutput.getOutput() != null
            &amp;&amp; StringUtils.isNotEmpty(sessionOutput.getOutput())) {

          outputList.add(sessionOutput);

          // send to audit logger

          if (systemOptions.enableInternalAudit) {
            sessionAuditService.audit(connectedSystem, sessionOutput.getOutput());
          }

          userSessionsOutput
              .getSessionOutputMap()
              .put(key, new SessionOutput(connectedSystem));
        }
      }
    }

    return outputList;
  }*/

  /**
   * returns list of output lines
   *
   * @return session output list
   */
  public List&lt;Session.TerminalMessage&gt; getOutput(ConnectedSystem connectedSystem, Long time, TimeUnit unit,
                                                 Predicate&lt;SessionOutput&gt; predicate)
      throws SQLException, InterruptedException {
<span class="nc" id="L196">    List&lt;Session.TerminalMessage&gt; nextTerminalMessage = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L198">    UserSessionsOutput userSessionsOutput = userSessionsOutputMap.get(connectedSystem.getSession().getId());</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">    if (userSessionsOutput != null) {</span>

<span class="nc bnc" id="L201" title="All 2 branches missed.">      for (Long key : userSessionsOutput.getSessionOutputMap().keySet()) {</span>

        // get output chars and set to output
<span class="nc" id="L204">        SessionOutput sessionOutput = userSessionsOutput.getSessionOutputMap().get(key);</span>

<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (sessionOutput != null) {</span>
<span class="nc" id="L207">          var output = sessionOutput.waitForOutput(</span>
              time, unit, predicate);


          // send to audit logger

<span class="nc bnc" id="L213" title="All 2 branches missed.">          if (systemOptions.enableInternalAudit) {</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">            if (output.getOutputMessage() != null) {</span>
              // this should already be audited when client types
              // fix for issue GH-8, where we saw duplicate messages.
             // sessionAuditService.audit(connectedSystem, output.getOutputMessage().getCommand());
            }
          }
<span class="nc bnc" id="L220" title="All 2 branches missed.">          if (output.getOutputMessage() != null) {</span>
<span class="nc" id="L221">            nextTerminalMessage.add(output.getOutputMessage());</span>
          }
<span class="nc bnc" id="L223" title="All 4 branches missed.">          if (null != output.getTriggers() &amp;&amp; !output.getTriggers().isEmpty()) {</span>
<span class="nc" id="L224">            nextTerminalMessage.addAll(output.getTriggers());</span>
          }

/*
          sessionOutput.clearOutput();
          userSessionsOutput
              .getSessionOutputMap()
              .put(key, new SessionOutput(connectedSystem));
*/
          // */
<span class="nc" id="L234">        } else {</span>
<span class="nc" id="L235">          Thread.sleep(50);</span>
        }
<span class="nc" id="L237">      }</span>
    }

<span class="nc" id="L240">    return nextTerminalMessage;</span>
  }

  public void addTrigger(ConnectedSystem connectedSystem, Trigger trigger) {
<span class="nc" id="L244">    UserSessionsOutput userSessionsOutput = userSessionsOutputMap.get(connectedSystem.getSession().getId());</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">    if (userSessionsOutput != null) {</span>
<span class="nc bnc" id="L246" title="All 6 branches missed.">      switch(trigger.getAction()){</span>
<span class="nc" id="L247">        case NO_ACTION, WARN_ACTION -&gt; userSessionsOutput.getSessionOutputMap().get(connectedSystem.getSession().getId()).addWarning(trigger);</span>
<span class="nc" id="L248">        case PERSISTENT_MESSAGE -&gt; userSessionsOutput.getSessionOutputMap().get(connectedSystem.getSession().getId()).addPersistentMessage(trigger);</span>
<span class="nc" id="L249">        case PROMPT_ACTION -&gt; userSessionsOutput.getSessionOutputMap().get(connectedSystem.getSession().getId()).addPrompt(trigger);</span>
<span class="nc" id="L250">        case JIT_ACTION -&gt; userSessionsOutput.getSessionOutputMap().get(connectedSystem.getSession().getId()).addJIT(trigger);</span>
<span class="nc" id="L251">        case DENY_ACTION -&gt; userSessionsOutput.getSessionOutputMap().get(connectedSystem.getSession().getId()).addDenial(trigger);</span>
      }
    }
<span class="nc" id="L254">  }</span>

  public void addSystemTrigger(ConnectedSystem connectedSystem, Trigger trigger) {
<span class="nc" id="L257">    UserSessionsOutput userSessionsOutput = userSessionsOutputMap.get(connectedSystem.getSession().getId());</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">    if (userSessionsOutput != null) {</span>
<span class="nc" id="L259">      userSessionsOutput.getSessionOutputMap().get(connectedSystem.getSession().getId()).addSystemMessage(trigger);</span>
    }
<span class="nc" id="L261">  }</span>


  public ConnectedSystem getConnectedSession(Long sessionId) {
<span class="nc" id="L265">    return userConnectionMap.get(sessionId);</span>
  }

  public ConnectedSystem getEncryptedConnectedSession(String sessionId) {
<span class="nc" id="L269">    return userConnectionMapEncrypted.get(sessionId);</span>
  }

  public boolean userContainsActiveTunnel(Long userId, Long sessionId, Long proxySessionId) {
<span class="nc" id="L273">    return userConnectionMap.containsKey(sessionId);</span>
  }

  public void closeSession(ConnectedSystem connectedSystem){
<span class="nc" id="L277">    removeOutput(connectedSystem);</span>
<span class="nc" id="L278">    removeUserSession(connectedSystem);</span>
<span class="nc" id="L279">    sessionAuditService.closeSession(connectedSystem.getSession().getId());</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">    if (null != connectedSystem.getCommander()) {</span>
<span class="nc" id="L281">      log.trace(&quot;Closed commander&quot;);</span>
<span class="nc" id="L282">      connectedSystem.getCommander().close();</span>
    }
    try {
<span class="nc" id="L285">        connectedSystem.getInputToChannel().close();</span>
<span class="nc" id="L286">        log.trace(&quot;Closed input channel&quot;);</span>
<span class="nc" id="L287">    } catch (Exception e) {</span>
<span class="nc" id="L288">      log.trace(&quot;Ignoring &quot; + e.getMessage());</span>
      // ignore
<span class="nc" id="L290">    }</span>

    try {
<span class="nc" id="L293">        connectedSystem.getOutFromChannel().close();</span>
<span class="nc" id="L294">      log.trace(&quot;Closed input channel&quot;);</span>
<span class="nc" id="L295">    } catch (Exception e) {</span>
<span class="nc" id="L296">      log.trace(&quot;Ignoring &quot; + e.getMessage());</span>
        // ignore
<span class="nc" id="L298">    }</span>



<span class="nc" id="L302">      connectedSystem.getSession().setClosed(true);</span>
<span class="nc" id="L303">  }</span>

  public void shutdown() {
<span class="nc bnc" id="L306" title="All 2 branches missed.">    for(ConnectedSystem connectedSystem : userConnectionMap.values()){</span>
<span class="nc" id="L307">      log.trace(&quot;Closing &quot; + connectedSystem.getSession().getId());</span>
<span class="nc" id="L308">      closeSession(connectedSystem);</span>
<span class="nc" id="L309">    }</span>
<span class="nc" id="L310">  }</span>

  public void resize(long sessionIdLong, double cols, double rows) {
<span class="nc" id="L313">    var connectedSystem = userConnectionMap.get(sessionIdLong);</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">    if (connectedSystem != null) {</span>
<span class="nc" id="L315">      ChannelShell channel = (ChannelShell) connectedSystem.getChannel();</span>
<span class="nc" id="L316">      channel.setPtySize(</span>
<span class="nc" id="L317">          (int) Math.floor(cols / 11),</span>
<span class="nc" id="L318">          (int) Math.floor(rows/ 17),</span>
          0,
          0);
    }

<span class="nc" id="L323">  }</span>

  public List&lt;ConnectedSystem&gt; getOpenSessions(User user) {
<span class="nc" id="L326">    List&lt;ConnectedSystem&gt; connectedSystems = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">    for (ConnectedSystem connectedSystem : userConnectionMap.values()) {</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">      if (connectedSystem.getUser().getId().equals(user.getId())) {</span>
<span class="nc" id="L329">        connectedSystems.add(connectedSystem);</span>
      }
<span class="nc" id="L331">    }</span>
<span class="nc" id="L332">    return connectedSystems;</span>
  }

  public void flushSessionOutput(ConnectedSystem sessionIdLong) {
<span class="nc" id="L336">    sessionAuditService.flushLogs(sessionIdLong);</span>
<span class="nc" id="L337">  }</span>

  public void refreshSession(ConnectedSystem myConnectedSystem) {
<span class="nc" id="L340">    log.trace(&quot;Getting terminal logs for session &quot; + myConnectedSystem.getSession().getId());</span>
<span class="nc" id="L341">    var terminalLogs = sessionAuditService.getTerminalLogsForSession(myConnectedSystem.getSession().getId());</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">    if (null != terminalLogs) {</span>
<span class="nc" id="L343">      log.trace(&quot;Found terminal logs for session &quot; + myConnectedSystem.getSession().getId());</span>
<span class="nc" id="L344">      SessionOutput sessionOutput = new SessionOutput(myConnectedSystem);</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">      for (var vlog : terminalLogs) {</span>
<span class="nc" id="L346">        log.trace(&quot;Adding log to session &quot; + myConnectedSystem.getSession().getId());</span>
<span class="nc" id="L347">        sessionOutput.append(vlog.getOutput());</span>
<span class="nc" id="L348">      }</span>
<span class="nc" id="L349">      addOutput(sessionOutput);</span>
    }
<span class="nc" id="L351">  }</span>

  public void addPersistentMessage(ConnectedSystem connectedSystem, PersistentMessage persistentMessage) {
<span class="nc" id="L354">    throw new UnsupportedOperationException(&quot;Not implemented&quot;);</span>
  }

  @Override
  public String getName() {
<span class="nc" id="L359">    return &quot;sessiontrackingService&quot;;</span>
  }

  @Override
  public boolean isEnabled() {
<span class="nc" id="L364">    return true;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>